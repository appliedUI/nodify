[
  {
    "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "type": "VueComponent",
    "label": "Vue",
    "code": "<template>\n  <div class=\"user-input-container\">\n    <h1>{{ title }}</h1>\n    <input v-model=\"inputText\" placeholder=\"Enter your text\" />\n    <button @click=\"submitInput\">Submit</button>\n    <p>{{ response }}</p>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue';\nimport { useUserStore } from '@/stores/userStore';\nimport { fetchAIResponse } from '@/utils/aiHelper';\n\nconst props = defineProps({\n  title: {\n    type: String,\n    default: 'User Input'\n  }\n});\n\nconst emit = defineEmits(['inputSubmitted']);\n\nconst inputText = ref('');\nconst response = ref('');\n\nconst userStore = useUserStore();\n\nconst submitInput = async () => {\n  if (inputText.value.trim()) {\n    userStore.addInput(inputText.value);\n    response.value = 'Processing...';\n    try {\n      const aiResponse = await fetchAIResponse(inputText.value);\n      response.value = aiResponse;\n      emit('inputSubmitted', aiResponse);\n    } catch (error) {\n      response.value = 'Error fetching AI response.';\n      console.error(error);\n    }\n  }\n};\n</script>\n\n<style scoped>\n.user-input-container {\n  max-width: 500px;\n  margin: 0 auto;\n  padding: 20px;\n  border: 1px solid #ccc;\n  border-radius: 8px;\n  text-align: center;\n}\ninput {\n  width: 80%;\n  padding: 8px;\n  margin: 10px 0;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n}\nbutton {\n  padding: 10px 20px;\n  background-color: #42b883;\n  color: white;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n}\nbutton:hover {\n  background-color: #369870;\n}\n</style>",
    "description": "A complete Vue 3 component using the <script setup> syntax. It includes data binding, event handling, interaction with a Pinia store, and integration with an AI helper script.",
    "agentPrompt": "As a seasoned front-end engineer, perform a comprehensive review of this Vue 3 code. Focus on its <script setup> structure, reactivity, and state management integration with Pinia. Examine and integrate how the component fetches AI-generated responses, handles potential errors, and emits events back to its parent. Offer recommendations for optimizing performance, improving code readability, and strengthening error handling. Additionally, suggest enhancements to the componentâ€™s styling and accessibility practices."
  },
  {
    "id": "b2c3d4e5-f6a7-8901-bcde-f23456789012",
    "type": "PiniaStore",
    "label": "PiniaStore",
    "code": "import { defineStore } from 'pinia';\n\nexport const useUserStore = defineStore('userStore', {\n  state: () => ({\n    inputs: []\n  }),\n  actions: {\n    addInput(newInput) {\n      this.inputs.push({\n        text: newInput,\n        timestamp: new Date()\n      });\n    },\n    clearInputs() {\n      this.inputs = [];\n    }\n  },\n  getters: {\n    inputCount: (state) => state.inputs.length,\n    recentInput: (state) => state.inputs[state.inputs.length - 1]\n  }\n});",
    "description": "Defines a Pinia store for managing user inputs. It includes state, actions to modify the state, and getters for derived state.",
    "agentPrompt": "Acting as a senior application architect, thoroughly review this Pinia store. Analyze how it manages user input data, from creation and mutation to derived state using getters. Suggest approaches for handling asynchronous operations (like API calls) and discuss how you would integrate this store with other parts of a growing application. Provide best practices for writing unit tests that ensure reliability of actions and getters. Additionally, propose ways to keep the store modular and scalable in the long term."
  },
  {
    "id": "c3d4e5f6-a7b8-9012-cdef-345678901234",
    "type": "ExpressAPI",
    "label": "ExpressAPI",
    "code": "const express = require('express');\nconst router = express.Router();\nconst { processInput } = require('../controllers/inputController');\n\n// POST /api/submit\nrouter.post('/submit', async (req, res) => {\n  const { userInput } = req.body;\n  if (!userInput) {\n    return res.status(400).json({ message: 'User input is required.' });\n  }\n  try {\n    const result = await processInput(userInput);\n    res.status(200).json({ response: result });\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'Server error.' });\n  }\n});\n\nmodule.exports = router;",
    "description": "An Express.js API endpoint that handles POST requests to submit user input. It processes the input using a controller and returns the result.",
    "agentPrompt": "As a full-stack engineer focused on building secure and scalable APIs, evaluate this Express.js endpoint. Examine the POST request handling, including how it validates and processes user input. Identify potential security concerns (e.g., lack of sanitization, susceptibility to injection). Recommend best practices for handling errors, logging, and rate limiting to safeguard the endpoint. Propose improvements in structure and middleware usage to ensure maintainability, alongside strategies for providing more informative responses to clients."
  },
  {
    "id": "d4e5f6g7-b8c9-0123-def0-456789012345",
    "type": "MongoDBAccessScript",
    "label": "Mongo DB",
    "code": "const mongoose = require('mongoose');\n\nconst connectDB = async () => {\n  try {\n    await mongoose.connect(process.env.MONGODB_URI, {\n      useNewUrlParser: true,\n      useUnifiedTopology: true\n    });\n    console.log('MongoDB connected successfully.');\n  } catch (error) {\n    console.error('MongoDB connection error:', error);\n    process.exit(1);\n  }\n};\n\nmodule.exports = connectDB;\n\n// Example Mongoose Schema and Model\nconst userInputSchema = new mongoose.Schema({\n  text: { type: String, required: true },\n  timestamp: { type: Date, default: Date.now }\n});\n\nconst UserInput = mongoose.model('UserInput', userInputSchema);\n\nmodule.exports.UserInput = UserInput;",
    "description": "Sets up a MongoDB connection using Mongoose and defines a schema and model for storing user inputs.",
    "agentPrompt": "From the perspective of a senior backend engineer, analyze this MongoDB access script. Review how the connection is initialized, including environment variable usage and error handling. Examine the `UserInput` schema for data integrity and performance considerations (e.g., indexing, validation, or potential sharding strategies). Propose architectural improvements for different environments and discuss how to handle schema migrations gracefully. Offer recommendations on structuring the database layer to support future scalability and reliability."
  },
  {
    "id": "e5f6g7h8-c9d0-1234-ef01-567890123456",
    "type": "AIHelperScript",
    "label": "AI API",
    "code": "const { Configuration, OpenAIApi } = require('openai');\n\nconst configuration = new Configuration({\n  apiKey: process.env.OPENAI_API_KEY\n});\n\nconst openai = new OpenAIApi(configuration);\n\n/**\n * Fetches a response from OpenAI based on the user input.\n * @param {string} input - The user's input text.\n * @returns {Promise<string>} - The AI-generated response.\n */\nconst fetchAIResponse = async (input) => {\n  try {\n    const response = await openai.createCompletion({\n      model: 'text-davinci-003',\n      prompt: `Respond to the following input in a helpful manner:\\n\\n${input}`,\n      max_tokens: 150,\n      temperature: 0.7\n    });\n    return response.data.choices[0].text.trim();\n  } catch (error) {\n    console.error('Error fetching AI response:', error);\n    throw new Error('AI service unavailable.');\n  }\n};\n\nmodule.exports = { fetchAIResponse };",
    "description": "A helper script that connects to OpenAI's API to fetch AI-generated responses based on user input. It uses the OpenAI SDK and handles configuration and error management.",
    "agentPrompt": "As a senior solutions architect with AI integration experience, thoroughly review how this script interacts with the OpenAI API. Evaluate the request configuration, including model selection, prompt construction, and token usage. Identify areas to improve error handling, such as providing clearer feedback or implementing retries. Offer strategies for managing multiple AI models, optimizing usage to reduce costs, and enhancing security around API keys. Finally, propose methods for dynamic prompt generation and robust logging to support effective debugging and monitoring."
  }
]
