[
  {
    "id": "ros-camera-node",
    "type": "ROSCamera",
    "label": "Camera",
    "code": "#!/usr/bin/env python3\nimport rospy\nfrom sensor_msgs.msg import Image\nfrom cv_bridge import CvBridge, CvBridgeError\nimport cv2\n\nclass CameraSubscriber:\n    def __init__(self):\n        # Initialize the ROS node\n        rospy.init_node('camera_subscriber', anonymous=True)\n        \n        # Create a CvBridge object to convert ROS images to OpenCV images\n        self.bridge = CvBridge()\n        \n        # Subscribe to the camera topic\n        self.image_sub = rospy.Subscriber('camera/image_raw', Image, self.callback)\n        \n        # Store the latest image\n        self.latest_image = None\n    \n    def callback(self, data):\n        try:\n            # Convert ROS Image message to OpenCV image\n            cv_image = self.bridge.imgmsg_to_cv2(data, 'bgr8')\n            self.latest_image = cv_image\n            \n            # Process image here\n            # Example: Display the image\n            cv2.imshow('Camera Feed', cv_image)\n            cv2.waitKey(1)\n            \n        except CvBridgeError as e:\n            print(e)\n    \n    def run(self):\n        try:\n            rospy.spin()\n        except KeyboardInterrupt:\n            print('Shutting down')\n            cv2.destroyAllWindows()\n\nif __name__ == '__main__':\n    camera_subscriber = CameraSubscriber()\n    camera_subscriber.run()",
    "description": "A ROS node that subscribes to a camera topic and processes the incoming image stream using OpenCV.",
    "agentPrompt": "As a robotics engineer, review this ROS camera node implementation. Focus on the image processing pipeline, error handling, and integration with the ROS ecosystem. Consider the efficiency of the image conversion process and suggest optimizations for real-time performance. Additionally, examine the node's robustness in handling different image formats and potential connection issues."
  },
  {
    "id": "ros-cmd-vel-node",
    "type": "ROSCmdVel",
    "label": "Command Velocity",
    "code": "#!/usr/bin/env python3\nimport rospy\nfrom geometry_msgs.msg import Twist\n\nclass CmdVelPublisher:\n    def __init__(self):\n        # Initialize the ROS node\n        rospy.init_node('cmd_vel_publisher', anonymous=True)\n        \n        # Create a publisher for the /cmd_vel topic\n        self.cmd_vel_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=10)\n        \n        # Set the loop rate\n        self.rate = rospy.Rate(10)  # 10 Hz\n        \n    def move_robot(self, linear_x, angular_z):\n        twist = Twist()\n        twist.linear.x = linear_x\n        twist.angular.z = angular_z\n        self.cmd_vel_pub.publish(twist)\n        rospy.loginfo(f'Published Twist: linear_x={linear_x}, angular_z={angular_z}')\n\n    def run(self):\n        try:\n            while not rospy.is_shutdown():\n                # Example: Move forward with linear velocity 0.5 m/s\n                self.move_robot(0.5, 0.0)\n                self.rate.sleep()\n        except rospy.ROSInterruptException:\n            pass\n\nif __name__ == '__main__':\n    cmd_vel_publisher = CmdVelPublisher()\n    cmd_vel_publisher.run()",
    "description": "A ROS node that publishes velocity commands to control the robot's movement via the /cmd_vel topic.",
    "agentPrompt": "As a robotics developer, evaluate this ROS Command Velocity node. Assess how it publishes velocity commands to control the robot's movement, including the choice of message type and publishing rate. Suggest improvements for handling dynamic command inputs, integrating with joystick controllers, and ensuring smooth acceleration and deceleration. Additionally, consider safety features to prevent abrupt movements or collisions."
  },
  {
    "id": "ros-odom-node",
    "type": "ROSOdom",
    "label": "Odometry",
    "code": "#!/usr/bin/env python3\nimport rospy\nfrom nav_msgs.msg import Odometry\nfrom geometry_msgs.msg import Pose, Twist\nimport tf\n\nclass OdometryPublisher:\n    def __init__(self):\n        rospy.init_node('odometry_publisher', anonymous=True)\n        self.odom_pub = rospy.Publisher('/odom', Odometry, queue_size=50)\n        self.odom_broadcaster = tf.TransformBroadcaster()\n        \n        # Robot state\n        self.x = 0.0\n        self.y = 0.0\n        self.th = 0.0\n        self.vx = 0.0\n        self.vy = 0.0\n        self.vth = 0.0\n        \n        self.rate = rospy.Rate(10)  # 10 Hz\n\n    def update_odometry(self):\n        current_time = rospy.Time.now()\n        dt = 1.0 / 10  # Assuming 10 Hz\n        \n        # Simple odometry calculation\n        delta_x = self.vx * dt\n        delta_y = self.vy * dt\n        delta_th = self.vth * dt\n        \n        self.x += delta_x\n        self.y += delta_y\n        self.th += delta_th\n        \n        # Publish the transform over tf\n        self.odom_broadcaster.sendTransform(\n            (self.x, self.y, 0.),\n            tf.transformations.quaternion_from_euler(0, 0, self.th),\n            current_time,\n            'base_link',\n            'odom'\n        )\n        \n        # Publish the odometry message\n        odom = Odometry()\n        odom.header.stamp = current_time\n        odom.header.frame_id = 'odom'\n        \n        # Set the position\n        odom.pose.pose = Pose()\n        odom.pose.pose.position.x = self.x\n        odom.pose.pose.position.y = self.y\n        odom.pose.pose.position.z = 0.\n        odom.pose.pose.orientation = tf.transformations.quaternion_from_euler(0, 0, self.th)\n        \n        # Set the velocity\n        odom.child_frame_id = 'base_link'\n        odom.twist.twist = Twist()\n        odom.twist.twist.linear.x = self.vx\n        odom.twist.twist.linear.y = self.vy\n        odom.twist.twist.angular.z = self.vth\n        \n        self.odom_pub.publish(odom)\n        rospy.loginfo(f'Odometry: x={self.x}, y={self.y}, th={self.th}')\n\n    def run(self):\n        while not rospy.is_shutdown():\n            self.update_odometry()\n            self.rate.sleep()\n\nif __name__ == '__main__':\n    odom_publisher = OdometryPublisher()\n    odom_publisher.run()",
    "description": "A ROS node that publishes odometry information to the /odom topic and broadcasts the transform between 'odom' and 'base_link' frames.",
    "agentPrompt": "As a robotics systems engineer, assess this ROS Odometry node implementation. Examine the accuracy of the odometry calculations and the integration with the tf transform broadcaster. Recommend enhancements for incorporating sensor data (e.g., wheel encoders, IMU) to improve odometry precision. Additionally, suggest ways to handle drift over time and synchronize odometry updates with sensor callbacks."
  },
  {
    "id": "ros-lidar-node",
    "type": "ROSLidar",
    "label": "LiDAR",
    "code": "#!/usr/bin/env python3\nimport rospy\nfrom sensor_msgs.msg import LaserScan\nimport random\n\nclass LidarPublisher:\n    def __init__(self):\n        rospy.init_node('lidar_publisher', anonymous=True)\n        self.lidar_pub = rospy.Publisher('/scan', LaserScan, queue_size=10)\n        self.rate = rospy.Rate(10)  # 10 Hz\n\n    def publish_scan(self):\n        scan = LaserScan()\n        scan.header.stamp = rospy.Time.now()\n        scan.header.frame_id = 'laser_frame'\n        scan.angle_min = -1.57  # -90 degrees\n        scan.angle_max = 1.57   # 90 degrees\n        scan.angle_increment = 3.14 / 180  # 1 degree\n        scan.time_increment = (1 / 10) / (3.14 / 180)\n        scan.range_min = 0.2\n        scan.range_max = 10.0\n        \n        num_readings = int((scan.angle_max - scan.angle_min) / scan.angle_increment)\n        scan.ranges = [random.uniform(0.2, 10.0) for _ in range(num_readings)]\n        scan.intensities = [random.uniform(0, 1) for _ in range(num_readings)]\n        \n        self.lidar_pub.publish(scan)\n        rospy.loginfo('Published LaserScan data')\n\n    def run(self):\n        while not rospy.is_shutdown():\n            self.publish_scan()\n            self.rate.sleep()\n\nif __name__ == '__main__':\n    lidar_publisher = LidarPublisher()\n    lidar_publisher.run()",
    "description": "A ROS node that publishes simulated LiDAR data to the /scan topic using the LaserScan message type.",
    "agentPrompt": "As a robotics software engineer, evaluate this ROS LiDAR node. Analyze the simulation of LaserScan data and its adherence to realistic LiDAR specifications. Suggest modifications to integrate actual LiDAR hardware data instead of simulated values. Additionally, consider optimizing the publishing rate and handling sensor noise to ensure reliable perception for navigation and obstacle avoidance."
  },
  {
    "id": "ros-tf-node",
    "type": "ROSTF",
    "label": "Transform",
    "code": "#!/usr/bin/env python3\nimport rospy\nimport tf\nfrom geometry_msgs.msg import TransformStamped\n\nclass TFBroadcaster:\n    def __init__(self):\n        rospy.init_node('tf_broadcaster', anonymous=True)\n        self.br = tf.TransformBroadcaster()\n        self.rate = rospy.Rate(10)  # 10 Hz\n\n    def broadcast_transform(self):\n        # Example: Broadcast transform from 'odom' to 'base_link'\n        translation = (0.0, 0.0, 0.0)\n        rotation = tf.transformations.quaternion_from_euler(0, 0, 0)\n        \n        self.br.sendTransform(\n            translation,\n            rotation,\n            rospy.Time.now(),\n            'base_link',\n            'odom'\n        )\n        rospy.loginfo('Broadcasted transform from odom to base_link')\n\n    def run(self):\n        while not rospy.is_shutdown():\n            self.broadcast_transform()\n            self.rate.sleep()\n\nif __name__ == '__main__':\n    tf_broadcaster = TFBroadcaster()\n    tf_broadcaster.run()",
    "description": "A ROS node that broadcasts the transform between 'odom' and 'base_link' frames using the tf package.",
    "agentPrompt": "As a ROS middleware specialist, review this ROS Transform broadcaster node. Assess the accuracy and consistency of the published transforms, ensuring proper frame hierarchy and timestamp alignment. Recommend enhancements for dynamic transforms based on robot movement or sensor data. Additionally, explore integrating with tf2 for improved performance and flexibility, and suggest best practices for managing multiple transform broadcasters in a complex robotic system."
  },
  {
    "id": "ros-battery-node",
    "type": "ROSBattery",
    "label": "Battery State",
    "code": "#!/usr/bin/env python3\nimport rospy\nfrom sensor_msgs.msg import BatteryState\nimport random\n\nclass BatteryPublisher:\n    def __init__(self):\n        rospy.init_node('battery_publisher', anonymous=True)\n        self.battery_pub = rospy.Publisher('/battery_state', BatteryState, queue_size=10)\n        self.rate = rospy.Rate(1)  # 1 Hz\n\n    def publish_battery_state(self):\n        battery = BatteryState()\n        battery.header.stamp = rospy.Time.now()\n        battery.voltage = random.uniform(11.0, 12.6)\n        battery.current = random.uniform(-5.0, 5.0)\n        battery.percentage = random.uniform(0.0, 1.0)\n        battery.power_supply_status = BatteryState.POWER_SUPPLY_STATUS_DISCHARGING\n        battery.power_supply_health = BatteryState.POWER_SUPPLY_HEALTH_GOOD\n        battery.power_supply_technology = BatteryState.POWER_SUPPLY_TECHNOLOGY_LIPO\n        \n        self.battery_pub.publish(battery)\n        rospy.loginfo(f'Published BatteryState: {battery.percentage * 100:.2f}%')\n\n    def run(self):\n        while not rospy.is_shutdown():\n            self.publish_battery_state()\n            self.rate.sleep()\n\nif __name__ == '__main__':\n    battery_publisher = BatteryPublisher()\n    battery_publisher.run()",
    "description": "A ROS node that publishes simulated battery state information to the /battery_state topic using the BatteryState message type.",
    "agentPrompt": "As a robotics power systems engineer, evaluate this ROS Battery State node. Examine the simulation of battery parameters and their relevance to real-world scenarios. Suggest methods to integrate actual battery monitoring hardware data instead of simulated values. Additionally, consider implementing state transitions (e.g., charging, discharging) and handling low battery warnings to enhance the robot's power management capabilities."
  },
  {
    "id": "ros-gps-node",
    "type": "ROSGPS",
    "label": "GPS",
    "code": "#!/usr/bin/env python3\nimport rospy\nfrom sensor_msgs.msg import NavSatFix\nimport random\n\nclass GPSPublisher:\n    def __init__(self):\n        rospy.init_node('gps_publisher', anonymous=True)\n        self.gps_pub = rospy.Publisher('/gps/fix', NavSatFix, queue_size=10)\n        self.rate = rospy.Rate(1)  # 1 Hz\n\n    def publish_gps_data(self):\n        gps = NavSatFix()\n        gps.header.stamp = rospy.Time.now()\n        gps.header.frame_id = 'gps'\n        \n        # Simulated coordinates\n        gps.latitude = 37.7749 + random.uniform(-0.0001, 0.0001)\n        gps.longitude = -122.4194 + random.uniform(-0.0001, 0.0001)\n        gps.altitude = 30.0 + random.uniform(-0.5, 0.5)\n        \n        # Fix status\n        gps.status.status = NavSatFix.STATUS_FIX\n        gps.status.service = NavSatFix.SERVICE_GPS\n        \n        # Position covariance\n        gps.position_covariance = [0.5, 0, 0, 0, 0.5, 0, 0, 0, 0.5]\n        gps.position_covariance_type = NavSatFix.COVARIANCE_TYPE_APPROXIMATED\n        \n        self.gps_pub.publish(gps)\n        rospy.loginfo(f'Published GPS Fix: lat={gps.latitude}, lon={gps.longitude}, alt={gps.altitude}')\n\n    def run(self):\n        while not rospy.is_shutdown():\n            self.publish_gps_data()\n            self.rate.sleep()\n\nif __name__ == '__main__':\n    gps_publisher = GPSPublisher()\n    gps_publisher.run()",
    "description": "A ROS node that publishes simulated GPS data to the /gps/fix topic using the NavSatFix message type.",
    "agentPrompt": "As a robotics navigation specialist, assess this ROS GPS node implementation. Evaluate the realism of the simulated GPS data and its suitability for navigation algorithms. Recommend integrating actual GPS hardware data, handling signal loss or inaccuracies, and fusing GPS data with other localization methods (e.g., odometry, IMU) to improve the robot's positioning accuracy. Additionally, consider implementing geofencing or waypoint tracking based on GPS coordinates."
  },
  {
    "id": "ros-imu-node",
    "type": "ROSIMU",
    "label": "IMU",
    "code": "#!/usr/bin/env python3\nimport rospy\nfrom sensor_msgs.msg import Imu\nimport random\n\nclass IMUPublisher:\n    def __init__(self):\n        rospy.init_node('imu_publisher', anonymous=True)\n        self.imu_pub = rospy.Publisher('/imu/data', Imu, queue_size=10)\n        self.rate = rospy.Rate(50)  # 50 Hz\n\n    def publish_imu_data(self):\n        imu = Imu()\n        imu.header.stamp = rospy.Time.now()\n        imu.header.frame_id = 'imu_link'\n        \n        # Simulated orientation (quaternion)\n        imu.orientation.x = 0.0\n        imu.orientation.y = 0.0\n        imu.orientation.z = 0.0\n        imu.orientation.w = 1.0\n        \n        # Simulated angular velocity\n        imu.angular_velocity.x = random.uniform(-0.1, 0.1)\n        imu.angular_velocity.y = random.uniform(-0.1, 0.1)\n        imu.angular_velocity.z = random.uniform(-0.1, 0.1)\n        \n        # Simulated linear acceleration\n        imu.linear_acceleration.x = random.uniform(-0.5, 0.5)\n        imu.linear_acceleration.y = random.uniform(-0.5, 0.5)\n        imu.linear_acceleration.z = random.uniform(-9.8, 9.8)\n        \n        self.imu_pub.publish(imu)\n        rospy.loginfo('Published IMU data')\n\n    def run(self):\n        while not rospy.is_shutdown():\n            self.publish_imu_data()\n            self.rate.sleep()\n\nif __name__ == '__main__':\n    imu_publisher = IMUPublisher()\n    imu_publisher.run()",
    "description": "A ROS node that publishes simulated IMU (Inertial Measurement Unit) data to the /imu/data topic using the Imu message type.",
    "agentPrompt": "As a robotics sensor integration engineer, review this ROS IMU node. Assess the simulation of orientation, angular velocity, and linear acceleration data for realism and relevance to motion estimation algorithms. Suggest integrating actual IMU hardware data, calibrating sensor measurements, and handling sensor noise and biases. Additionally, consider fusing IMU data with other sensors (e.g., GPS, odometry) to enhance the robot's state estimation and navigation accuracy."
  },
  {
    "id": "ros-joy-node",
    "type": "ROSJoy",
    "label": "Joystick",
    "code": "#!/usr/bin/env python3\nimport rospy\nfrom sensor_msgs.msg import Joy\nfrom geometry_msgs.msg import Twist\n\nclass JoystickController:\n    def __init__(self):\n        rospy.init_node('joystick_controller', anonymous=True)\n        \n        self.joy_sub = rospy.Subscriber('/joy', Joy, self.joy_callback)\n        self.cmd_vel_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=10)\n        \n        self.twist = Twist()\n        \n    def joy_callback(self, data):\n        # Assuming axis 1 is forward/backward and axis 0 is left/right\n        self.twist.linear.x = data.axes[1] * 1.0  # Scale to max 1 m/s\n        self.twist.angular.z = data.axes[0] * 1.0  # Scale to max 1 rad/s\n        \n        self.cmd_vel_pub.publish(self.twist)\n        rospy.loginfo(f'Published Twist: linear_x={self.twist.linear.x}, angular_z={self.twist.angular.z}')\n\n    def run(self):\n        rospy.spin()\n\nif __name__ == '__main__':\n    joystick_controller = JoystickController()\n    joystick_controller.run()",
    "description": "A ROS node that subscribes to joystick inputs on the /joy topic and publishes velocity commands to the /cmd_vel topic based on joystick movements.",
    "agentPrompt": "As a human-robot interaction specialist, evaluate this ROS Joystick Controller node. Examine how joystick inputs are mapped to velocity commands and ensure responsiveness and accuracy in control. Suggest implementing dead zones to prevent unintended movements, scaling inputs for finer control, and handling multiple joystick buttons for additional functionalities (e.g., emergency stop, mode switching). Additionally, consider integrating feedback mechanisms to inform the user of the robot's state."
  },
  {
    "id": "ros-diagnostics-node",
    "type": "ROSDiagnostics",
    "label": "Diagnostics",
    "code": "#!/usr/bin/env python3\nimport rospy\nfrom diagnostic_msgs.msg import DiagnosticArray, DiagnosticStatus, KeyValue\n\nclass DiagnosticsPublisher:\n    def __init__(self):\n        rospy.init_node('diagnostics_publisher', anonymous=True)\n        self.diagnostics_pub = rospy.Publisher('/diagnostics', DiagnosticArray, queue_size=10)\n        self.rate = rospy.Rate(1)  # 1 Hz\n\n    def publish_diagnostics(self):\n        diag_array = DiagnosticArray()\n        diag_array.header.stamp = rospy.Time.now()\n        \n        # Example diagnostic status\n        status = DiagnosticStatus()\n        status.name = 'Robot Status'\n        status.level = DiagnosticStatus.OK\n        status.message = 'All systems operational'\n        status.values = [\n            KeyValue(key='Battery', value='Good'),\n            KeyValue(key='CPU Usage', value='45%'),\n            KeyValue(key='Memory Usage', value='60%')\n        ]\n        \n        diag_array.status.append(status)\n        \n        self.diagnostics_pub.publish(diag_array)\n        rospy.loginfo('Published diagnostics information')\n\n    def run(self):\n        while not rospy.is_shutdown():\n            self.publish_diagnostics()\n            self.rate.sleep()\n\nif __name__ == '__main__':\n    diagnostics_publisher = DiagnosticsPublisher()\n    diagnostics_publisher.run()",
    "description": "A ROS node that publishes diagnostic information to the /diagnostics topic using the DiagnosticArray message type.",
    "agentPrompt": "As a robotics systems monitor engineer, assess this ROS Diagnostics Publisher node. Evaluate the types of diagnostic information being published and their relevance to system health monitoring. Suggest incorporating real-time data from various subsystems (e.g., sensors, actuators, communication links) to provide a comprehensive diagnostic overview. Additionally, consider implementing different diagnostic levels (OK, WARN, ERROR) and integrating with visualization tools like rqt_robot_monitor for effective system diagnostics and troubleshooting."
  },
  {
    "id": "ros-motor-control-node",
    "type": "ROSMotorControl",
    "label": "Motor Control",
    "code": "#!/usr/bin/env python3\nimport rospy\nfrom std_msgs.msg import Float32\n\nclass MotorController:\n    def __init__(self):\n        rospy.init_node('motor_controller', anonymous=True)\n        \n        # Subscribe to motor speed commands\n        self.motor_sub = rospy.Subscriber('/motor_speed', Float32, self.motor_callback)\n        \n        # Publisher to motor hardware interface (simulated here)\n        self.motor_pub = rospy.Publisher('/hardware/motor', Float32, queue_size=10)\n        \n        self.current_speed = 0.0\n\n    def motor_callback(self, data):\n        desired_speed = data.data\n        rospy.loginfo(f'Received motor speed command: {desired_speed} RPM')\n        \n        # Simple control logic (e.g., PID controller can be added)\n        self.current_speed = desired_speed  # Direct assignment for simulation\n        \n        # Publish to motor hardware interface\n        self.motor_pub.publish(self.current_speed)\n        rospy.loginfo(f'Published motor speed: {self.current_speed} RPM')\n\n    def run(self):\n        rospy.spin()\n\nif __name__ == '__main__':\n    motor_controller = MotorController()\n    motor_controller.run()",
    "description": "A ROS node that subscribes to motor speed commands on the /motor_speed topic and publishes control signals to the motor hardware interface.",
    "agentPrompt": "As a robotics actuator control engineer, review this ROS Motor Control node. Assess the simplicity of directly assigning desired speeds and suggest implementing control algorithms (e.g., PID controllers) for accurate motor speed regulation. Recommend integrating feedback from motor encoders to adjust commands based on actual performance. Additionally, consider handling motor saturation, implementing safety checks to prevent over-speeding, and ensuring smooth acceleration and deceleration to enhance motor control reliability and longevity."
  },
  {
    "id": "ros-robot-state-node",
    "type": "ROSRobotState",
    "label": "Robot State",
    "code": "#!/usr/bin/env python3\nimport rospy\nfrom std_msgs.msg import String\n\nclass RobotStatePublisher:\n    def __init__(self):\n        rospy.init_node('robot_state_publisher', anonymous=True)\n        self.state_pub = rospy.Publisher('/robot_state', String, queue_size=10)\n        self.rate = rospy.Rate(1)  # 1 Hz\n        \n        # Initial state\n        self.state = 'Idle'\n\n    def update_state(self):\n        # Example state transitions\n        if self.state == 'Idle':\n            self.state = 'Active'\n        elif self.state == 'Active':\n            self.state = 'Charging'\n        elif self.state == 'Charging':\n            self.state = 'Idle'\n        \n        self.state_pub.publish(self.state)\n        rospy.loginfo(f'Published Robot State: {self.state}')\n\n    def run(self):\n        while not rospy.is_shutdown():\n            self.update_state()\n            self.rate.sleep()\n\nif __name__ == '__main__':\n    robot_state_publisher = RobotStatePublisher()\n    robot_state_publisher.run()",
    "description": "A ROS node that publishes the robot's current state to the /robot_state topic using the String message type.",
    "agentPrompt": "As a robotics systems integrator, evaluate this ROS Robot State Publisher node. Analyze the simplicity of state transitions and suggest integrating more complex state management using state machines (e.g., SMACH) for better scalability and maintainability. Recommend incorporating real-time state updates based on sensor inputs, task completions, or error conditions. Additionally, consider providing more detailed state information using custom message types to convey comprehensive system statuses."
  },
  {
    "id": "ros-memory-monitor-node",
    "type": "ROSMemoryMonitor",
    "label": "Memory Monitor",
    "code": "#!/usr/bin/env python3\nimport rospy\nfrom diagnostic_msgs.msg import DiagnosticArray, DiagnosticStatus, KeyValue\nimport psutil\n\nclass MemoryMonitor:\n    def __init__(self):\n        rospy.init_node('memory_monitor', anonymous=True)\n        self.diagnostics_pub = rospy.Publisher('/diagnostics', DiagnosticArray, queue_size=10)\n        self.rate = rospy.Rate(1)  # 1 Hz\n\n    def publish_memory_diagnostics(self):\n        diag_array = DiagnosticArray()\n        diag_array.header.stamp = rospy.Time.now()\n        \n        mem = psutil.virtual_memory()\n        \n        status = DiagnosticStatus()\n        status.name = 'Memory Usage'\n        status.level = DiagnosticStatus.OK\n        status.message = 'Memory usage is normal'\n        \n        if mem.percent > 80:\n            status.level = DiagnosticStatus.WARN\n            status.message = 'High memory usage'\n        \n        status.values = [\n            KeyValue(key='Total', value=f'{mem.total / (1024 ** 3):.2f} GB'),\n            KeyValue(key='Used', value=f'{mem.used / (1024 ** 3):.2f} GB'),\n            KeyValue(key='Available', value=f'{mem.available / (1024 ** 3):.2f} GB'),\n            KeyValue(key='Usage', value=f'{mem.percent}%')\n        ]\n        \n        diag_array.status.append(status)\n        \n        self.diagnostics_pub.publish(diag_array)\n        rospy.loginfo(f'Published Memory Diagnostics: {mem.percent}% used')\n\n    def run(self):\n        while not rospy.is_shutdown():\n            self.publish_memory_diagnostics()\n            self.rate.sleep()\n\nif __name__ == '__main__':\n    memory_monitor = MemoryMonitor()\n    memory_monitor.run()",
    "description": "A ROS node that monitors system memory usage and publishes diagnostics information to the /diagnostics topic.",
    "agentPrompt": "As a robotics system reliability engineer, assess this ROS Memory Monitor node. Evaluate the use of psutil for accurate memory usage detection and the integration with ROS diagnostics for system health monitoring. Suggest adding thresholds for different warning and error levels, incorporating trends over time, and handling memory leaks or spikes more effectively. Additionally, consider extending the monitor to include other system resources (e.g., CPU, disk usage) for a more comprehensive diagnostics suite."
  },
  {
    "id": "ros-network-monitor-node",
    "type": "ROSNetworkMonitor",
    "label": "Network Monitor",
    "code": "#!/usr/bin/env python3\nimport rospy\nfrom diagnostic_msgs.msg import DiagnosticArray, DiagnosticStatus, KeyValue\nimport psutil\n\nclass NetworkMonitor:\n    def __init__(self):\n        rospy.init_node('network_monitor', anonymous=True)\n        self.diagnostics_pub = rospy.Publisher('/diagnostics', DiagnosticArray, queue_size=10)\n        self.rate = rospy.Rate(1)  # 1 Hz\n\n    def publish_network_diagnostics(self):\n        diag_array = DiagnosticArray()\n        diag_array.header.stamp = rospy.Time.now()\n        \n        net = psutil.net_io_counters()\n        \n        status = DiagnosticStatus()\n        status.name = 'Network Usage'\n        status.level = DiagnosticStatus.OK\n        status.message = 'Network usage is normal'\n        \n        # Example: Check if packets sent exceed a threshold\n        if net.packets_sent > 10000:\n            status.level = DiagnosticStatus.WARN\n            status.message = 'High number of packets sent'\n        \n        status.values = [\n            KeyValue(key='Bytes Sent', value=f'{net.bytes_sent / (1024 ** 2):.2f} MB'),\n            KeyValue(key='Bytes Received', value=f'{net.bytes_recv / (1024 ** 2):.2f} MB'),\n            KeyValue(key='Packets Sent', value=str(net.packets_sent)),\n            KeyValue(key='Packets Received', value=str(net.packets_recv))\n        ]\n        \n        diag_array.status.append(status)\n        \n        self.diagnostics_pub.publish(diag_array)\n        rospy.loginfo(f'Published Network Diagnostics: {net.packets_sent} packets sent')\n\n    def run(self):\n        while not rospy.is_shutdown():\n            self.publish_network_diagnostics()\n            self.rate.sleep()\n\nif __name__ == '__main__':\n    network_monitor = NetworkMonitor()\n    network_monitor.run()",
    "description": "A ROS node that monitors network usage and publishes diagnostics information to the /diagnostics topic.",
    "agentPrompt": "As a robotics network systems engineer, evaluate this ROS Network Monitor node. Assess the accuracy and relevance of the network metrics being monitored and their impact on the robot's performance. Suggest expanding the diagnostics to include latency, packet loss, and bandwidth utilization for a more comprehensive network health overview. Additionally, consider implementing alerts or automated responses to network issues, such as switching to backup connections or throttling data-intensive processes to maintain system stability."
  },
  {
    "id": "ros-log-monitor-node",
    "type": "ROSLogMonitor",
    "label": "Log Monitor",
    "code": "#!/usr/bin/env python3\nimport rospy\nfrom diagnostic_msgs.msg import DiagnosticArray, DiagnosticStatus, KeyValue\nimport logging\n\nclass LogMonitor:\n    def __init__(self):\n        rospy.init_node('log_monitor', anonymous=True)\n        self.diagnostics_pub = rospy.Publisher('/diagnostics', DiagnosticArray, queue_size=10)\n        self.rate = rospy.Rate(1)  # 1 Hz\n        \n        # Configure logging\n        logging.basicConfig(filename='/var/log/robotics.log', level=logging.INFO)\n\n    def publish_log_diagnostics(self):\n        diag_array = DiagnosticArray()\n        diag_array.header.stamp = rospy.Time.now()\n        \n        try:\n            with open('/var/log/robotics.log', 'r') as log_file:\n                lines = log_file.readlines()\n                error_count = sum(1 for line in lines if 'ERROR' in line)\n                warn_count = sum(1 for line in lines if 'WARN' in line)\n        except Exception as e:\n            error_count = 0\n            warn_count = 0\n            rospy.logerr(f'Failed to read log file: {e}')\n        \n        status = DiagnosticStatus()\n        status.name = 'Log Monitoring'\n        if error_count > 0:\n            status.level = DiagnosticStatus.ERROR\n            status.message = f'{error_count} errors found in logs'\n        elif warn_count > 0:\n            status.level = DiagnosticStatus.WARN\n            status.message = f'{warn_count} warnings found in logs'\n        else:\n            status.level = DiagnosticStatus.OK\n            status.message = 'No errors or warnings in logs'\n        \n        status.values = [\n            KeyValue(key='Errors', value=str(error_count)),\n            KeyValue(key='Warnings', value=str(warn_count))\n        ]\n        \n        diag_array.status.append(status)\n        \n        self.diagnostics_pub.publish(diag_array)\n        rospy.loginfo(f'Published Log Diagnostics: {error_count} errors, {warn_count} warnings')\n\n    def run(self):\n        while not rospy.is_shutdown():\n            self.publish_log_diagnostics()\n            self.rate.sleep()\n\nif __name__ == '__main__':\n    log_monitor = LogMonitor()\n    log_monitor.run()",
    "description": "A ROS node that monitors robot logs and publishes diagnostics information regarding errors and warnings to the /diagnostics topic.",
    "agentPrompt": "As a robotics software quality engineer, assess this ROS Log Monitor node. Evaluate its effectiveness in detecting and reporting errors and warnings from the robot's log files. Suggest implementing real-time log parsing, integrating with centralized logging systems (e.g., ROS log aggregators), and enhancing the diagnostic messages with actionable insights. Additionally, consider adding support for different log levels, filtering specific log sources, and automating responses to critical log events to improve overall system reliability and maintainability."
  }
]
